<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no"/>
<title>PsyForge ‚Äî Kaleidoscope (Hi-Res Recording)</title>
<style>
  :root{
    --glass: rgba(18,18,22,.86);
    --fg:#eaf4ff; --muted:#b9c5db; --line:#2a3246;
    --accent:#77f0ff; --danger:#ff6b6b; --ok:#7dffb0;
  }
  html,body{margin:0;height:100%;background:#000;color:var(--fg);font-family:ui-sans-serif,system-ui,Segoe UI,Roboto,Helvetica,Arial}
  canvas{display:block;width:100vw;height:100vh;touch-action:none;cursor:grab;background:#000}
  /* top dock */
  #dock{
    position:fixed; left:50%; top:10px; transform:translateX(-50%);
    display:flex; flex-wrap:wrap; gap:.5rem 1rem; align-items:center;
    padding:.6rem .8rem; z-index:50;
    background:var(--glass); border:1px solid var(--line); border-radius:.7rem; backdrop-filter: blur(8px);
    box-shadow:0 8px 34px rgba(0,0,0,.35);
  }
  .group{display:flex; gap:.5rem; align-items:center; flex-wrap:wrap}
  label{font-size:.85rem; color:var(--muted)}
  input[type="range"]{width:130px}
  .btn{
    appearance:none; border:1px solid var(--line); border-radius:.5rem; padding:.45rem .7rem;
    background:#10131a; color:var(--fg); font-weight:600; letter-spacing:.2px; cursor:pointer;
  }
  .btn:hover{border-color:#3b4a66}
  .btn.danger{ background:#1d0e10; border-color:#5b2a30; color:#ffdfe1 }
  .btn.ok{ background:#0f1a14; border-color:#274a35; color:#d7ffe9 }
  .tiny{font-size:.8rem; opacity:.8}
  #stat{min-width:160px}
  /* bottom-left mini helper */
  #help {
    position: fixed; left: 10px; bottom: 10px; z-index: 50; color: var(--muted); font-size: .82rem;
    background: rgba(0,0,0,.4); padding:.4rem .55rem; border:1px solid var(--line); border-radius:.5rem
  }
</style>
</head>
<body>
  <canvas id="stage"></canvas>

  <div id="dock">
    <div class="group">
      <label>Image <input id="file" type="file" accept="image/*"></label>
      <label>Wedges <input id="wedges" type="range" min="2" max="16" step="1" value="8"></label>
      <label>Zoom <input id="zoom" type="range" min="0.2" max="4" step="0.01" value="1"></label>
      <label>Rotate <input id="rotate" type="range" min="-180" max="180" step="0.1" value="0"></label>
      <label>Twist <input id="twist" type="range" min="-180" max="180" step="0.1" value="0"></label>
    </div>
    <div class="group">
      <button id="rec-start" class="btn ok">‚óè Record</button>
      <button id="rec-stop"  class="btn danger">‚ñ† Stop & Download</button>
      <button id="shot" class="btn">üì∑ Snapshot</button>
    </div>
    <div id="stat" class="tiny"></div>
  </div>

  <div id="help">Drag = pan ‚Ä¢ Wheel/pinch = zoom ‚Ä¢ Rotate/Twist sliders spin the pattern</div>

<script>
/* =======================
   HI-RES CANVAS FOUNDATION
   ======================= */
const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d', { alpha:false });
const EXPORT_SCALE = 1; // set 2 for ultra-high res if device can handle it

function resizeCanvasHiRes() {
  const dpr = window.devicePixelRatio || 1;
  const cssW = Math.max(1, Math.floor(window.innerWidth));
  const cssH = Math.max(1, Math.floor(window.innerHeight));
  const pxW = Math.floor(cssW * dpr * EXPORT_SCALE);
  const pxH = Math.floor(cssH * dpr * EXPORT_SCALE);
  if (canvas.width !== pxW || canvas.height !== pxH) {
    canvas.width = pxW; canvas.height = pxH;
    canvas.style.width = cssW + 'px'; canvas.style.height = cssH + 'px';
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr * EXPORT_SCALE, dpr * EXPORT_SCALE);
  }
}
resizeCanvasHiRes();
window.addEventListener('resize', resizeCanvasHiRes, { passive:true });

/* ==========
   STATE
   ========== */
const ui = {
  wedges: document.getElementById('wedges'),
  zoom:   document.getElementById('zoom'),
  rotate: document.getElementById('rotate'),
  twist:  document.getElementById('twist'),
  file:   document.getElementById('file'),
  recStart: document.getElementById('rec-start'),
  recStop:  document.getElementById('rec-stop'),
  shot:     document.getElementById('shot'),
  stat:     document.getElementById('stat')
};

let img = new Image();
let imgReady = false;
let panX = 0, panY = 0;           // pan in screen (CSS) pixels
let autoRot = 0;                  // gentle rotation for motion
let isPointerDown = false;
let lastX = 0, lastY = 0;

/* ===============
   IMAGE LOADING
   =============== */
ui.file.addEventListener('change', (e) => {
  const f = e.target.files && e.target.files[0];
  if (!f) return;
  const url = URL.createObjectURL(f);
  img.onload = () => { imgReady = true; URL.revokeObjectURL(url); };
  img.src = url;
});

/* ======================
   POINTER / TOUCH INPUT
   ====================== */
canvas.addEventListener('pointerdown', (e) => {
  isPointerDown = true; canvas.setPointerCapture(e.pointerId);
  lastX = e.clientX; lastY = e.clientY;
});
canvas.addEventListener('pointermove', (e) => {
  if (!isPointerDown) return;
  const dx = e.clientX - lastX;
  const dy = e.clientY - lastY;
  panX += dx; panY += dy;
  lastX = e.clientX; lastY = e.clientY;
});
canvas.addEventListener('pointerup', () => { isPointerDown = false; });
canvas.addEventListener('pointercancel', () => { isPointerDown = false; });

// Wheel to zoom; keep center focus at cursor
canvas.addEventListener('wheel', (e) => {
  e.preventDefault();
  const rect = canvas.getBoundingClientRect();
  const cx = e.clientX - rect.left;
  const cy = e.clientY - rect.top;
  const prevZoom = parseFloat(ui.zoom.value);
  const factor = Math.exp(-e.deltaY * 0.001);
  const nextZoom = Math.min(4, Math.max(0.2, prevZoom * factor));
  // adjust pan so the point under cursor stays stable
  panX = cx - (cx - panX) * (nextZoom/prevZoom);
  panY = cy - (cy - panY) * (nextZoom/prevZoom);
  ui.zoom.value = nextZoom.toFixed(2);
}, { passive:false });

/* ======================
   KALEIDOSCOPE DRAW
   ====================== */
function drawKaleidoscope() {
  const w = window.innerWidth, h = window.innerHeight;
  ctx.clearRect(0,0,w,h);

  // Soft gradient background (so it looks nice even before an image is loaded)
  const bg = ctx.createRadialGradient(w/2, h/2, Math.min(w,h)*0.1, w/2, h/2, Math.max(w,h)*0.8);
  bg.addColorStop(0, 'hsl(' + ((autoRot*40)%360) + ', 90%, 7%)');
  bg.addColorStop(1, 'black');
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,w,h);

  const n = parseInt(ui.wedges.value, 10);
  const zoom = parseFloat(ui.zoom.value);
  const rotDeg = parseFloat(ui.rotate.value);
  const twistDeg = parseFloat(ui.twist.value);

  const cx = w/2, cy = h/2;
  const slice = (Math.PI * 2) / n;
  const rot = (rotDeg * Math.PI / 180) + autoRot * 0.2;
  const twist = twistDeg * Math.PI / 180;

  for (let i=0; i<n; i++){
    ctx.save();
    ctx.translate(cx, cy);
    ctx.rotate(rot + i * slice);

    // Clip to triangular wedge
    ctx.beginPath();
    ctx.moveTo(0,0);
    ctx.arc(0,0, Math.max(w,h), -slice/2, slice/2);
    ctx.closePath();
    ctx.clip();

    // Mirror every other wedge for a classic kaleidoscope look
    if (i % 2 === 1) ctx.scale(-1,1);

    // Draw content inside wedge
    ctx.save();
    ctx.rotate(i * (twist / n)); // subtle cumulative twist
    ctx.translate(panX - cx, panY - cy); // pan in screen coords
    ctx.scale(zoom, zoom);

    if (imgReady) {
      // Center image
      const iw = img.naturalWidth, ih = img.naturalHeight;
      const s = Math.max(w/iw, h/ih) * 1.1; // slight overscale to avoid gaps
      const drawW = iw * s, drawH = ih * s;
      ctx.drawImage(img, cx - drawW/2, cy - drawH/2, drawW, drawH);
    } else {
      // fallback pattern if no image yet
      for (let r=0; r<8; r++){
        ctx.globalAlpha = 0.12;
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,255,255,.9)';
        ctx.beginPath();
        ctx.moveTo(0,0);
        const ang = (r*0.7 + autoRot*3);
        ctx.lineTo(Math.cos(ang)*w, Math.sin(ang)*h);
        ctx.stroke();
      }
    }

    ctx.restore();
    ctx.restore();
  }

  autoRot += 1/60; // gentle motion
  requestAnimationFrame(drawKaleidoscope);
}
requestAnimationFrame(drawKaleidoscope);

/* =======================
   SNAPSHOT (PNG DOWNLOAD)
   ======================= */
ui.shot.addEventListener('click', () => {
  // Use the internal high-res pixels
  const data = canvas.toDataURL('image/png');
  const a = document.createElement('a');
  a.href = data;
  const ts = new Date().toISOString().replace(/[:.]/g,'-');
  a.download = `psyforge_snapshot_${canvas.width}x${canvas.height}_${ts}.png`;
  document.body.appendChild(a); a.click(); a.remove();
});

/* ============================
   HIGH-QUALITY VIDEO RECORDING
   ============================ */
let mediaRecorder = null;
let recChunks = [];

function pickMime() {
  const prefs = ['video/webm;codecs=vp9','video/webm;codecs=vp8','video/webm'];
  for (const t of prefs) if ('MediaRecorder' in window && MediaRecorder.isTypeSupported(t)) return t;
  return undefined;
}

function startRecording({ fps=60, bitrate=12_000_000 } = {}) {
  if (mediaRecorder && mediaRecorder.state === 'recording') return;
  const stream = canvas.captureStream(fps); // records at full internal (hi-res) size
  recChunks = [];
  const opts = { mimeType: pickMime(), videoBitsPerSecond: bitrate };
  mediaRecorder = new MediaRecorder(stream, opts);

  mediaRecorder.ondataavailable = e => { if (e.data && e.data.size) recChunks.push(e.data); };
  mediaRecorder.onstop = () => {
    const blob = new Blob(recChunks, { type: mediaRecorder.mimeType || 'video/webm' });
    const url = URL.createObjectURL(blob);
    const ts = new Date().toISOString().replace(/[:.]/g,'-');
    const name = `psyforge_${canvas.width}x${canvas.height}_${ts}.webm`;
    const a = document.createElement('a'); a.href = url; a.download = name;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 10_000);
    ui.stat.textContent = 'Saved: ' + name;
  };

  mediaRecorder.start();
  ui.stat.textContent = `Recording @ ${fps}fps, ${(opts.videoBitsPerSecond/1e6).toFixed(1)} Mbps`;
}
function stopRecording() {
  if (mediaRecorder && mediaRecorder.state === 'recording') {
    setTimeout(()=> mediaRecorder.stop(), 60);
    ui.stat.textContent = 'Finishing‚Ä¶';
  }
}

ui.recStart.addEventListener('click', () => startRecording({ fps:60, bitrate:12_000_000 }));
ui.recStop .addEventListener('click', stopRecording);
</script>
</body>
</html>
